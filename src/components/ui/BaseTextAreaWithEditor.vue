<script setup lang="ts">
import { ref, watch, nextTick, onMounted, defineProps, defineEmits } from 'vue';

const props = defineProps<{
  label: string;
  modelValue: string;
}>();
const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
}>();

// Основные состояния
const content = ref(props.modelValue || '');
const editorRef = ref<HTMLDivElement | null>(null);
const isHtmlView = ref(false);
const undoStack = ref<string[]>([]);
const redoStack = ref<string[]>([]);
const textAlign = ref<'left' | 'center' | 'right' | 'justify'>('left');
const headerLevel = ref<number | null>(null);

// НОВЫЙ ФЛАГ: указывает, что изменение произошло внутри компонента,
// чтобы игнорировать обратную синхронизацию из props.modelValue.
const isInternalChange = ref(false);

// Синхронизация с внешним modelValue (только обновляем content)
watch(
    [() => props.modelValue, isHtmlView],
    ([val, htmlView]) => {
      // Игнорируем, если изменение пришло от нас самих (из onInput)
      if (isInternalChange.value) {
        isInternalChange.value = false;
        return;
      }

      if (val !== content.value) {
        content.value = val || '';
      }

      // Обновляем DOM только при внешнем изменении или переключении видов
      nextTick(() => {
        if (editorRef.value && !htmlView) {
          editorRef.value.innerHTML = content.value;
        }
      });
    },
    { immediate: true }
);

// Любые изменения content сразу наружу
watch(content, (val) => {
  emit('update:modelValue', val);
});

// Получение текущего диапазона (оставлено для функций форматирования)
function getSelectionRange() {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return null;
  return sel.getRangeAt(0).cloneRange();
}

// Вставка HTML с сохранением undo/redo
function insertHTML(html: string) {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return;
  const range = sel.getRangeAt(0);
  const frag = document.createRange().createContextualFragment(html);

  // Устанавливаем флаг перед изменением content.value
  isInternalChange.value = true;

  range.deleteContents();
  range.insertNode(frag);
  content.value = editorRef.value?.innerHTML || '';
  undoStack.value.push(content.value);
  redoStack.value = [];
}

// Оборачивание выделенного текста тегами и стилями
function wrapSelectionMultiple(tags: string[], style?: string, href?: string) {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return;
  const range = sel.getRangeAt(0);
  let selectedText = range.toString() || 'Text';
  if (href) selectedText = `<a href="${href}" target="_blank">${selectedText}</a>`;
  if (style) selectedText = `<span style="${style}">${selectedText}</span>`;
  for (const tag of tags) selectedText = `<${tag}>${selectedText}</${tag}>`;

  insertHTML(selectedText);
}

// Обработчик ввода (contenteditable)
function onInput() {
  if (!editorRef.value) return;

  // Устанавливаем флаг, чтобы watch игнорировал это изменение
  isInternalChange.value = true;

  // Просто обновляем content.value. Браузер сам сохранит курсор.
  content.value = editorRef.value.innerHTML;

  undoStack.value.push(content.value);
  redoStack.value = [];
}

// Undo / Redo
function undo() {
  if (undoStack.value.length === 0) return;

  // Устанавливаем флаг, чтобы избежать конфликтов при обновлении DOM
  isInternalChange.value = true;

  redoStack.value.push(content.value);
  content.value = undoStack.value.pop()!;

  if (editorRef.value && !isHtmlView.value) editorRef.value.innerHTML = content.value;
}

function redo() {
  if (redoStack.value.length === 0) return;

  // Устанавливаем флаг
  isInternalChange.value = true;

  undoStack.value.push(content.value);
  content.value = redoStack.value.pop()!;

  if (editorRef.value && !isHtmlView.value) editorRef.value.innerHTML = content.value;
}

// Очистка
function clear() {
  content.value = '';
  if (editorRef.value) editorRef.value.innerHTML = '';
  undoStack.value = [];
  redoStack.value = [];
  isInternalChange.value = true; // Сброс, чтобы не было конфликтов
}

// Ссылки и картинки
function insertLink() {
  const url = prompt('Введите URL:');
  if (url) wrapSelectionMultiple([], undefined, url);
}
function insertImage() {
  const url = prompt('Введите URL изображения:');
  if (url) insertHTML(`<img src="${url}" alt="Image" />`);
}

// Выравнивание текста
function applyAlignment(alignment: 'left' | 'center' | 'right' | 'justify') {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return;
  const range = sel.getRangeAt(0);
  let node: Node | null = range.startContainer;
  while (node && node !== editorRef.value) {
    if (node instanceof HTMLElement && getComputedStyle(node).display === 'block') break;
    node = node.parentElement;
  }

  // Устанавливаем флаг перед изменением content.value
  isInternalChange.value = true;

  if (!node || node === editorRef.value) {
    const div = document.createElement('div');
    div.style.textAlign = alignment;
    div.appendChild(range.extractContents());
    range.insertNode(div);
  } else {
    (node as HTMLElement).style.textAlign = alignment;
  }
  content.value = editorRef.value?.innerHTML || '';
  undoStack.value.push(content.value);
  redoStack.value = [];
}

// Заголовки
function applyHeader(level: number | null) {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return;
  const range = sel.getRangeAt(0);
  const selectedText = range.extractContents();
  const tag = level ? `h${level}` : 'p';
  const el = document.createElement(tag);
  el.appendChild(selectedText);
  range.insertNode(el);

  // Устанавливаем флаг перед изменением content.value
  isInternalChange.value = true;

  content.value = editorRef.value?.innerHTML || '';
  undoStack.value.push(content.value);
  redoStack.value = [];
}

// Цвет текста
function applyTextColor(color: string) {
  wrapSelectionMultiple([], `color: ${color}`);
}

// Фон текста
function applyBackgroundColor(color: string) {
  wrapSelectionMultiple([], `background-color: ${color}`);
}

onMounted(() => {
  if (editorRef.value) editorRef.value.innerHTML = content.value;
});
</script>

<template>
  <div class="editor-container w-full">
    <label class="block text-sm text-gray-700 mb-2">{{ label }}</label>

    <div class="flex flex-wrap gap-2 mb-2">
      <div class="toolbar-group flex gap-1">
        <select v-model.number="headerLevel" @change="applyHeader(headerLevel)" class="toolbar-select">
          <option :value="null">Normal</option>
          <option v-for="n in 6" :key="n" :value="n">H{{ n }}</option>
        </select>
        <button @click.prevent="wrapSelectionMultiple(['b'])" class="toolbar-button font-bold">B</button>
        <button @click.prevent="wrapSelectionMultiple(['i'])" class="toolbar-button italic">I</button>
        <button @click.prevent="wrapSelectionMultiple(['u'])" class="toolbar-button underline">U</button>
        <button @click.prevent="wrapSelectionMultiple(['strike'])" class="toolbar-button line-through">S</button>
      </div>

      <div class="toolbar-group flex gap-1">
        <button @click.prevent="wrapSelectionMultiple(['ul'])" class="toolbar-button">• List</button>
        <button @click.prevent="wrapSelectionMultiple(['ol'])" class="toolbar-button">1. List</button>
      </div>

      <div class="toolbar-group flex gap-1">
        <button @click.prevent="insertLink()" class="toolbar-button text-blue-600">Link</button>
        <button @click.prevent="insertImage()" class="toolbar-button text-green-600">Image</button>
      </div>

      <div class="toolbar-group flex gap-1">
        <select v-model="textAlign" @change="applyAlignment(textAlign)" class="toolbar-select">
          <option value="left">Left</option>
          <option value="center">Center</option>
          <option value="right">Right</option>
          <option value="justify">Justify</option>
        </select>
        <button @click.prevent="undo()" class="toolbar-button">Undo</button>
        <button @click.prevent="redo()" class="toolbar-button">Redo</button>
        <button @click.prevent="clear()" class="toolbar-button text-red-600">Clear</button>
      </div>

      <div class="toolbar-group flex gap-1 items-center">
        <label class="flex items-center gap-1">
          <span class="text-sm">Цвет текста:</span>
          <input type="color" @input="applyTextColor(($event.target as HTMLInputElement).value)" class="w-8 h-8 border rounded cursor-pointer"/>
        </label>
        <label class="flex items-center gap-1">
          <span class="text-sm">Фон:</span>
          <input type="color" @input="applyBackgroundColor(($event.target as HTMLInputElement).value)" class="w-8 h-8 border rounded cursor-pointer"/>
        </label>
      </div>

      <div class="toolbar-group flex gap-1 items-center">
        <label class="flex items-center gap-1">
          <input type="checkbox" v-model="isHtmlView" /> HTML
        </label>
      </div>
    </div>

    <div
        ref="editorRef"
        contenteditable="true"
        v-if="!isHtmlView"
        @input="onInput"
        class="editor min-h-[12em] max-h-[24em] mb-2.5 p-3 border rounded resize-none focus:outline-none focus:ring-2 focus:ring-blue-400 bg-white text-gray-800 w-full overflow-auto"
    ></div>

    <textarea
        v-else
        v-model="content"
        class="editor min-h-[12em] max-h-[24em] mb-2.5 p-3 border rounded resize-none focus:outline-none focus:ring-2 focus:ring-blue-400 bg-gray-100 text-gray-800 w-full overflow-auto"
    ></textarea>
  </div>
</template>

<style scoped>
.toolbar-button {
  padding: 0.25rem 0.5rem;
  border: 1px solid #cbd5e0;
  border-radius: 0.375rem;
  background: #fff;
  color: #374151;
  font-size: 0.875rem;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.toolbar-button:hover {
  background: #f3f4f6;
}
.toolbar-button:active {
  background: #e5e7eb;
}
.toolbar-select {
  border: 1px solid #cbd5e0;
  border-radius: 0.375rem;
  padding: 0.25rem 0.5rem;
  background: #fff;
  font-size: 0.875rem;
}
.toolbar-group {
  display: flex;
  gap: 0.25rem;
  align-items: center;
}
.editor:empty:before {
  content: attr(placeholder);
  color: #9ca3af;
}
div[contenteditable] {
  outline: none;
}
</style>